import Cocoa

// MARK: - Data Model
struct Port {
    let id: UUID = UUID()
    let item: String
    let amount: Double
    let isInput: Bool
    
    func frame(nodePosition: NSPoint, nodeIndex: Int, totalCount: Int) -> NSRect {
        let nodeWidth: CGFloat = 200
        let nodeHeight: CGFloat = 100
        let portSize: CGFloat = 12
        let spacing: CGFloat = 20
        let startY = nodePosition.y + 30 - CGFloat(nodeIndex) * spacing
        
        if isInput {
            return NSRect(x: nodePosition.x - nodeWidth/2 - portSize/2,
                         y: startY - portSize/2,
                         width: portSize, height: portSize)
        } else {
            return NSRect(x: nodePosition.x + nodeWidth/2 - portSize/2,
                         y: startY - portSize/2,
                         width: portSize, height: portSize)
        }
    }
}

struct FactorioNode {
    let id: UUID
    var recipeID: String
    var position: NSPoint
    var targetPerMin: Double?
    var modules: [Module?] = []
    
    var actualRate: Double {
            return targetPerMin ?? 0
        }
    
    var inputs: [Port] {
        guard let recipe = RECIPES.first(where: { $0.id == recipeID }) else { return [] }
        return recipe.inputs.map { Port(item: $0.key, amount: $0.value, isInput: true) }
    }
    
    var outputs: [Port] {
        guard let recipe = RECIPES.first(where: { $0.id == recipeID }) else { return [] }
        return recipe.outputs.map { Port(item: $0.key, amount: $0.value, isInput: false) }
    }
}

struct Edge: Identifiable {
    let id = UUID()
    var fromNode: UUID
    var fromPort: UUID
    var toNode: UUID
    var toPort: UUID
    var item: String
}

// NOW your ViewController class
class ViewController: NSViewController {
    let canvasView = CanvasView()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Set up the canvas view
        canvasView.frame = view.bounds
        canvasView.autoresizingMask = [.width, .height]
        view.addSubview(canvasView)
        
        // Add a test node to see it working
        let testNode = FactorioNode(
            id: UUID(),
            recipeID: "iron-plate",  // Assuming this exists in your Recipes
            position: NSPoint(x: 200, y: 200)
        )
        canvasView.nodes.append(testNode)
    }
}

// MARK: - Canvas View
class CanvasView: NSView {
    var nodes: [FactorioNode] = [] {
        didSet { needsDisplay = true }
    }
    var edges: [Edge] = [] {
        didSet { needsDisplay = true }
    }
    var selectedEdges: Set<UUID> = [] {
        didSet { needsDisplay = true }
    }
    // Selection and interaction state
    var selectedNodes: Set<UUID> = [] {
        didSet { needsDisplay = true }
    }
    var draggedNode: UUID?
    var dragOffset: NSPoint = .zero
    var isBoxSelecting = false
    var selectionStart: NSPoint = .zero
    var selectionEnd: NSPoint = .zero
    
    // Wire dragging state
    var isDraggingWire = false
    var wireStart: (nodeID: UUID, portID: UUID, point: NSPoint)?
    var wireEnd: NSPoint = .zero
    
    override init(frame frameRect: NSRect) {
        super.init(frame: frameRect)
        setupView()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupView()
    }
    
    func setupView() {
        wantsLayer = true
        layer?.backgroundColor = NSColor(white: 0.11, alpha: 1.0).cgColor
        
        // Add some test nodes
        addTestNodes()
    }
    
    func addTestNodes() {
        nodes = [
            FactorioNode(id: UUID(), recipeID: "iron-plate", position: NSPoint(x: 200, y: 300)),
            FactorioNode(id: UUID(), recipeID: "copper-plate", position: NSPoint(x: 450, y: 300)),
            FactorioNode(id: UUID(), recipeID: "electronic-circuit", position: NSPoint(x: 350, y: 150)),
            FactorioNode(id: UUID(), recipeID: "iron-gear-wheel", position: NSPoint(x: 200, y: 450))
        ]
    }
    
    override func draw(_ dirtyRect: NSRect) {
        guard let context = NSGraphicsContext.current?.cgContext else { return }
        
        // Draw grid dots
        drawGrid(in: context)
        
        // Draw edges BEFORE nodes so they appear behind
        context.setLineWidth(2)
        for edge in edges {
            drawEdge(edge, in: context)
        }
        
        // Draw dragging wire
        if isDraggingWire, let start = wireStart {
            drawDraggingWire(from: start.point, to: wireEnd, in: context)
        }
        
        // Draw selection box if active
        if isBoxSelecting {
            drawSelectionBox(in: context)
        }
        
        // Draw nodes
        for node in nodes {
            let isSelected = selectedNodes.contains(node.id)
            drawNode(node, in: context, isSelected: isSelected)
        }
    }
    
    func drawGrid(in context: CGContext) {
        context.setFillColor(NSColor.white.withAlphaComponent(0.05).cgColor)
        
        let spacing: CGFloat = 50
        let dotSize: CGFloat = 1.2
        
        for x in stride(from: spacing, to: bounds.width, by: spacing) {
            for y in stride(from: spacing, to: bounds.height, by: spacing) {
                context.fill(CGRect(x: x - dotSize/2, y: y - dotSize/2, width: dotSize, height: dotSize))
            }
        }
    }
    
    func drawNode(_ node: FactorioNode, in context: CGContext, isSelected: Bool) {
          let nodeRect = NSRect(x: node.position.x - 100, y: node.position.y - 50, width: 200, height: 100)
          
          // Background
          context.setFillColor(NSColor.black.withAlphaComponent(isSelected ? 0.9 : 0.8).cgColor)
          let path = CGPath(roundedRect: nodeRect, cornerWidth: 8, cornerHeight: 8, transform: nil)
          context.addPath(path)
          context.fillPath()
          
          // Border
          if isSelected {
              context.setStrokeColor(NSColor.orange.cgColor)
              context.setLineWidth(2)
          } else {
              context.setStrokeColor(NSColor.white.withAlphaComponent(0.2).cgColor)
              context.setLineWidth(1)
          }
          context.addPath(path)
          context.strokePath()
          
          // Get recipe for details
          guard let recipe = RECIPES.first(where: { $0.id == node.recipeID }) else { return }
          
          // Title
          let attrs: [NSAttributedString.Key: Any] = [
              .font: NSFont.systemFont(ofSize: 14, weight: .medium),
              .foregroundColor: NSColor.white
          ]
          
          let title = recipe.name as NSString
          title.draw(at: NSPoint(x: nodeRect.midX - title.size(withAttributes: attrs).width/2,
                                 y: nodeRect.maxY - 25), withAttributes: attrs)
          
          // ADD THIS: Show production rate
          if let rate = node.targetPerMin, rate > 0 {
              let rateText = String(format: "%.1f/min", rate) as NSString
              let rateAttrs: [NSAttributedString.Key: Any] = [
                  .font: NSFont.systemFont(ofSize: 12, weight: .bold),
                  .foregroundColor: NSColor.green
              ]
              rateText.draw(at: NSPoint(x: nodeRect.midX - rateText.size(withAttributes: rateAttrs).width/2,
                                        y: nodeRect.midY - 10), withAttributes: rateAttrs)
          }
        
        // Draw input ports
        for (index, port) in node.inputs.enumerated() {
            let portFrame = port.frame(nodePosition: node.position, nodeIndex: index, totalCount: node.inputs.count)
            drawPort(port, frame: portFrame, in: context)
            
            // Label
            let label = "\(port.item)" as NSString
            let labelAttrs: [NSAttributedString.Key: Any] = [
                .font: NSFont.systemFont(ofSize: 10),
                .foregroundColor: NSColor.white.withAlphaComponent(0.7)
            ]
            label.draw(at: NSPoint(x: portFrame.maxX + 4, y: portFrame.midY - 6), withAttributes: labelAttrs)
        }
        
        // Draw output ports
        for (index, port) in node.outputs.enumerated() {
            let portFrame = port.frame(nodePosition: node.position, nodeIndex: index, totalCount: node.outputs.count)
            drawPort(port, frame: portFrame, in: context)
            
            // Label
            let label = "\(port.item)" as NSString
            let labelAttrs: [NSAttributedString.Key: Any] = [
                .font: NSFont.systemFont(ofSize: 10),
                .foregroundColor: NSColor.white.withAlphaComponent(0.7)
            ]
            let size = label.size(withAttributes: labelAttrs)
            label.draw(at: NSPoint(x: portFrame.minX - size.width - 4, y: portFrame.midY - 6), withAttributes: labelAttrs)
        }
    }
    
    func drawPort(_ port: Port, frame: NSRect, in context: CGContext) {
        // Check if connected
        let isConnected = edges.contains { edge in
            (edge.fromPort == port.id || edge.toPort == port.id)
        }
        
        // Port circle
        context.setFillColor(isConnected ? NSColor.orange.cgColor : NSColor.gray.cgColor)
        context.fillEllipse(in: frame)
        
        // Port border
        context.setStrokeColor(NSColor.white.withAlphaComponent(0.5).cgColor)
        context.setLineWidth(1)
        context.strokeEllipse(in: frame)
    }
    
    func drawEdge(_ edge: Edge, in context: CGContext) {
        // Find the nodes and ports
        guard let fromNode = nodes.first(where: { $0.id == edge.fromNode }),
              let toNode = nodes.first(where: { $0.id == edge.toNode }),
              let fromPort = fromNode.outputs.first(where: { $0.id == edge.fromPort }),
              let toPort = toNode.inputs.first(where: { $0.id == edge.toPort }) else { return }
        
        let fromIndex = fromNode.outputs.firstIndex(where: { $0.id == edge.fromPort }) ?? 0
        let toIndex = toNode.inputs.firstIndex(where: { $0.id == edge.toPort }) ?? 0
        
        let fromFrame = fromPort.frame(nodePosition: fromNode.position,
                                       nodeIndex: fromIndex,
                                       totalCount: fromNode.outputs.count)
        let toFrame = toPort.frame(nodePosition: toNode.position,
                                   nodeIndex: toIndex,
                                   totalCount: toNode.inputs.count)
        
        // Draw bezier curve
        let path = NSBezierPath()
        path.move(to: NSPoint(x: fromFrame.midX, y: fromFrame.midY))
        
        let controlPointOffset = abs(toFrame.midX - fromFrame.midX) * 0.5
        path.curve(to: NSPoint(x: toFrame.midX, y: toFrame.midY),
                   controlPoint1: NSPoint(x: fromFrame.midX + controlPointOffset, y: fromFrame.midY),
                   controlPoint2: NSPoint(x: toFrame.midX - controlPointOffset, y: toFrame.midY))
        
        context.setStrokeColor(NSColor.orange.cgColor)
        context.addPath(path.cgPath)
        context.strokePath()
    }
    
    func drawDraggingWire(from: NSPoint, to: NSPoint, in context: CGContext) {
        let path = NSBezierPath()
        path.move(to: from)
        
        let controlPointOffset = abs(to.x - from.x) * 0.5
        path.curve(to: to,
                   controlPoint1: NSPoint(x: from.x + controlPointOffset, y: from.y),
                   controlPoint2: NSPoint(x: to.x - controlPointOffset, y: to.y))
        
        context.setStrokeColor(NSColor.blue.withAlphaComponent(0.8).cgColor)
        context.setLineDash(phase: 0, lengths: [5, 5])
        context.addPath(path.cgPath)
        context.strokePath()
    }
    
    func drawSelectionBox(in context: CGContext) {
        let rect = CGRect(
            x: min(selectionStart.x, selectionEnd.x),
            y: min(selectionStart.y, selectionEnd.y),
            width: abs(selectionEnd.x - selectionStart.x),
            height: abs(selectionEnd.y - selectionStart.y)
        )
        
        context.setFillColor(NSColor.blue.withAlphaComponent(0.1).cgColor)
        context.fill(rect)
        
        context.setStrokeColor(NSColor.blue.withAlphaComponent(0.5).cgColor)
        context.setLineWidth(1)
        context.stroke(rect)
    }
    
    
    // MARK: - Mouse Events
    override func mouseDown(with event: NSEvent) {
        let point = convert(event.locationInWindow, from: nil)
        
        // Check if we hit a port first
        if let (node, port, isInput) = portAt(point: point) {
            // Start wire dragging
            isDraggingWire = true
            wireStart = (nodeID: node.id, portID: port.id, point: point)
            wireEnd = point
            return
        }
        
        // Check if we hit a node
        if let hitNode = nodeAt(point: point) {
            if event.modifierFlags.contains(.shift) {
                // Toggle selection with shift
                if selectedNodes.contains(hitNode.id) {
                    selectedNodes.remove(hitNode.id)
                } else {
                    selectedNodes.insert(hitNode.id)
                }
            } else if !selectedNodes.contains(hitNode.id) {
                // Only change selection if clicking an unselected node
                selectedNodes = [hitNode.id]
            }
            
            // Set up for dragging (will drag all selected nodes)
            draggedNode = hitNode.id
            dragOffset = NSPoint(
                x: point.x - hitNode.position.x,
                y: point.y - hitNode.position.y
            )
        } else {
            // Start box selection
            selectedNodes.removeAll()
            isBoxSelecting = true
            selectionStart = point
            selectionEnd = point
        }
        
        needsDisplay = true
    }
    
    override func mouseDragged(with event: NSEvent) {
        let point = convert(event.locationInWindow, from: nil)
        
        if isDraggingWire {
            wireEnd = point
        } else if let draggedID = draggedNode {
            // Calculate the delta movement
            if let draggedNode = nodes.first(where: { $0.id == draggedID }) {
                let deltaX = (point.x - dragOffset.x) - draggedNode.position.x
                let deltaY = (point.y - dragOffset.y) - draggedNode.position.y
                
                // Move ALL selected nodes by the same delta
                for i in nodes.indices {
                    if selectedNodes.contains(nodes[i].id) {
                        nodes[i].position.x += deltaX
                        nodes[i].position.y += deltaY
                    }
                }
            }
        } else if isBoxSelecting {
            // Update selection box
            selectionEnd = point
        }
        
        needsDisplay = true
    }
    
    override func mouseUp(with event: NSEvent) {
        let point = convert(event.locationInWindow, from: nil)
        
        if isDraggingWire {
            // Check if we dropped on a compatible port
            if let start = wireStart,
               let (endNode, endPort, isInput) = portAt(point: point) {
                
                // Find which port is output and which is input
                if let startNode = nodes.first(where: { $0.id == start.nodeID }),
                   let startPort = (startNode.outputs + startNode.inputs).first(where: { $0.id == start.portID }) {
                    
                    // Create edge if compatible
                    if startPort.isInput != endPort.isInput && startPort.item == endPort.item {
                        let edge = Edge(
                            fromNode: startPort.isInput ? endNode.id : startNode.id,
                            fromPort: startPort.isInput ? endPort.id : startPort.id,
                            toNode: startPort.isInput ? startNode.id : endNode.id,
                            toPort: startPort.isInput ? startPort.id : endPort.id,
                            item: startPort.item
                        )
                        edges.append(edge)
                    }
                }
            }
            
            isDraggingWire = false
            wireStart = nil
        } else if isBoxSelecting {
            // Select all nodes in box
            let rect = CGRect(
                x: min(selectionStart.x, selectionEnd.x),
                y: min(selectionStart.y, selectionEnd.y),
                width: abs(selectionEnd.x - selectionStart.x),
                height: abs(selectionEnd.y - selectionStart.y)
            )
            
            selectedNodes.removeAll()
            for node in nodes {
                let nodeRect = NSRect(x: node.position.x - 100, y: node.position.y - 50, width: 200, height: 100)
                if rect.intersects(nodeRect) {
                    selectedNodes.insert(node.id)
                }
            }
        }
        
        // Reset drag state
        draggedNode = nil
        isBoxSelecting = false
        needsDisplay = true
    }
    
    // Add this to your CanvasView class, replacing the current rightMouseDown method:
    
    override func rightMouseDown(with event: NSEvent) {
        let point = convert(event.locationInWindow, from: nil)
        lastRightClickLocation = point
        
        // Check if we right-clicked on a node
        if let clickedNode = nodeAt(point: point) {
            // Show node-specific menu
            let menu = NSMenu()
            menu.addItem(NSMenuItem(title: "Set Production Target...", action: #selector(setProductionTarget(_:)), keyEquivalent: ""))
            menu.addItem(NSMenuItem.separator())
            menu.addItem(NSMenuItem(title: "Delete Node", action: #selector(deleteClickedNode), keyEquivalent: ""))
            
            // Store the clicked node for the menu actions
            lastClickedNodeID = clickedNode.id
            
            NSMenu.popUpContextMenu(menu, with: event, for: self)
            return
        }
        
        // Otherwise show the regular menu (existing code)
        let menu = NSMenu()
        
        // Create submenus by category
        let intermediatesMenu = NSMenu()
        intermediatesMenu.addItem(withTitle: "Iron Plate", action: #selector(addRecipe(_:)), keyEquivalent: "")
        intermediatesMenu.addItem(withTitle: "Copper Plate", action: #selector(addRecipe(_:)), keyEquivalent: "")
        intermediatesMenu.addItem(withTitle: "Steel Plate", action: #selector(addRecipe(_:)), keyEquivalent: "")
        intermediatesMenu.addItem(withTitle: "Iron Gear Wheel", action: #selector(addRecipe(_:)), keyEquivalent: "")
        intermediatesMenu.addItem(withTitle: "Copper Cable", action: #selector(addRecipe(_:)), keyEquivalent: "")
        intermediatesMenu.addItem(withTitle: "Electronic Circuit", action: #selector(addRecipe(_:)), keyEquivalent: "")
        intermediatesMenu.addItem(withTitle: "Advanced Circuit", action: #selector(addRecipe(_:)), keyEquivalent: "")
        intermediatesMenu.addItem(withTitle: "Processing Unit", action: #selector(addRecipe(_:)), keyEquivalent: "")
        
        let intermediatesItem = NSMenuItem(title: "Intermediates", action: nil, keyEquivalent: "")
        intermediatesItem.submenu = intermediatesMenu
        menu.addItem(intermediatesItem)
        
        // Science packs menu
        let scienceMenu = NSMenu()
        scienceMenu.addItem(withTitle: "Automation Science Pack", action: #selector(addRecipe(_:)), keyEquivalent: "")
        scienceMenu.addItem(withTitle: "Logistic Science Pack", action: #selector(addRecipe(_:)), keyEquivalent: "")
        scienceMenu.addItem(withTitle: "Chemical Science Pack", action: #selector(addRecipe(_:)), keyEquivalent: "")
        scienceMenu.addItem(withTitle: "Military Science Pack", action: #selector(addRecipe(_:)), keyEquivalent: "")
        scienceMenu.addItem(withTitle: "Production Science Pack", action: #selector(addRecipe(_:)), keyEquivalent: "")
        scienceMenu.addItem(withTitle: "Utility Science Pack", action: #selector(addRecipe(_:)), keyEquivalent: "")
        
        let scienceItem = NSMenuItem(title: "Science Packs", action: nil, keyEquivalent: "")
        scienceItem.submenu = scienceMenu
        menu.addItem(scienceItem)
        
        menu.addItem(NSMenuItem.separator())
        
        if !selectedNodes.isEmpty {
            menu.addItem(NSMenuItem(title: "Delete Selected", action: #selector(deleteSelected), keyEquivalent: ""))
        }
        
        NSMenu.popUpContextMenu(menu, with: event, for: self)
    }
    
    // Helper methods
    func nodeAt(point: NSPoint) -> FactorioNode? {
        for node in nodes.reversed() {  // Check top nodes first
            let nodeRect = NSRect(x: node.position.x - 100, y: node.position.y - 50, width: 200, height: 100)
            if nodeRect.contains(point) {
                return node
            }
        }
        return nil
    }
    
    func edgeAt(point: NSPoint) -> Edge? {
        for edge in edges {
            // Check if point is near the edge curve
            // This is simplified - you might want more precise hit testing
            guard let fromNode = nodes.first(where: { $0.id == edge.fromNode }),
                  let toNode = nodes.first(where: { $0.id == edge.toNode }) else { continue }
            
            // Simple bounding box check for now
            let minX = min(fromNode.position.x, toNode.position.x) - 50
            let maxX = max(fromNode.position.x, toNode.position.x) + 50
            let minY = min(fromNode.position.y, toNode.position.y) - 50
            let maxY = max(fromNode.position.y, toNode.position.y) + 50
            
            let bounds = NSRect(x: minX, y: minY, width: maxX - minX, height: maxY - minY)
            if bounds.contains(point) {
                // Could add more precise curve distance check here
                return edge
            }
        }
        return nil
    }
    
    func portAt(point: NSPoint) -> (node: FactorioNode, port: Port, isInput: Bool)? {
        for node in nodes {
            for (index, port) in node.inputs.enumerated() {
                let frame = port.frame(nodePosition: node.position, nodeIndex: index, totalCount: node.inputs.count)
                if frame.contains(point) {
                    return (node, port, true)
                }
            }
            for (index, port) in node.outputs.enumerated() {
                let frame = port.frame(nodePosition: node.position, nodeIndex: index, totalCount: node.outputs.count)
                if frame.contains(point) {
                    return (node, port, false)
                }
            }
        }
        return nil
    }
    
    func calculateFlows() {
            // Simple backward propagation from nodes with set targets
            var nodeRates: [UUID: Double] = [:]
            
            // First, find all nodes with manually set targets
            for node in nodes {
                if let target = node.targetPerMin {
                    nodeRates[node.id] = target
                }
            }
            
            // Then propagate requirements backward through the graph
            var changed = true
            while changed {
                changed = false
                
                for edge in edges {
                    guard let consumerNode = nodes.first(where: { $0.id == edge.toNode }),
                          let consumerRate = nodeRates[edge.toNode],
                          let consumerRecipe = RECIPES.first(where: { $0.id == consumerNode.recipeID }),
                          let supplierNode = nodes.first(where: { $0.id == edge.fromNode }),
                          let supplierRecipe = RECIPES.first(where: { $0.id == supplierNode.recipeID }) else {
                        continue
                    }
                    
                    // Calculate how much input the consumer needs
                    let inputNeeded = consumerRecipe.inputs[edge.item] ?? 0
                    let outputProvided = supplierRecipe.outputs[edge.item] ?? 1
                    
                    let requiredSupplierRate = (consumerRate * inputNeeded) / outputProvided
                    
                    if nodeRates[edge.fromNode] == nil || nodeRates[edge.fromNode]! < requiredSupplierRate {
                        nodeRates[edge.fromNode] = requiredSupplierRate
                        changed = true
                    }
                }
            }
            
            // Update all nodes with calculated rates
            for i in nodes.indices {
                nodes[i].targetPerMin = nodeRates[nodes[i].id]
            }
            
            needsDisplay = true
        }
    
    override var acceptsFirstResponder: Bool { true }
    
    override func keyDown(with event: NSEvent) {
        switch event.keyCode {
        case 51: // Delete key
            deleteSelected()
        case 0: // A key
            if event.modifierFlags.contains(.command) {
                // Select all
                selectedNodes = Set(nodes.map { $0.id })
                needsDisplay = true
            }
        default:
            super.keyDown(with: event)
        }
    }
    var lastClickedNodeID: UUID?
       
       @objc func setProductionTarget(_ sender: NSMenuItem) {
           guard let nodeID = lastClickedNodeID,
                 let nodeIndex = nodes.firstIndex(where: { $0.id == nodeID }) else { return }
           
           // For now, just set a test value - you'd want to show an input dialog here
           nodes[nodeIndex].targetPerMin = 60.0  // 60 items per minute
           calculateFlows()
       }
       
       @objc func deleteClickedNode() {
           if let nodeID = lastClickedNodeID {
               nodes.removeAll { $0.id == nodeID }
               edges.removeAll { $0.fromNode == nodeID || $0.toNode == nodeID }
           }
       }
    var lastRightClickLocation: NSPoint = .zero
    
    @objc func addIronPlate() {
        let node = FactorioNode(id: UUID(), recipeID: "iron-plate", position: lastRightClickLocation)
        nodes.append(node)
    }
    
    @objc func addCopperPlate() {
        let node = FactorioNode(id: UUID(), recipeID: "copper-plate", position: lastRightClickLocation)
        nodes.append(node)
    }
    
    @objc func addRecipe(_ sender: NSMenuItem) {
        let recipeName = sender.title
        if let recipe = RECIPES.first(where: { $0.name == recipeName }) {
            let node = FactorioNode(id: UUID(), recipeID: recipe.id, position: lastRightClickLocation)
            nodes.append(node)
        }
    }
    
    @objc func deleteSelected() {
        nodes.removeAll { selectedNodes.contains($0.id) }
        selectedNodes.removeAll()
    }
}

// MARK: - NSBezierPath Extension
extension NSBezierPath {
    var cgPath: CGPath {
        let path = CGMutablePath()
        var points = [CGPoint](repeating: .zero, count: 3)
        
        for i in 0..<elementCount {
            let type = element(at: i, associatedPoints: &points)
            switch type {
            case .moveTo:
                path.move(to: points[0])
            case .lineTo:
                path.addLine(to: points[0])
            case .curveTo:
                path.addCurve(to: points[2], control1: points[0], control2: points[1])
            case .closePath:
                path.closeSubpath()
            @unknown default:
                break
            }
        }
        
        return path
    }
}

